지금까지의 프로그램 클래스 = main 메서드 중심
java 명령을 실행 할 때는 main 메서드가 필요

1. 클래스 선언
필요한 자료들을 필드로 선언
클래스 선언은 '형'을 선언하는 것
실체 (변수)를 선언한느 것이 아니다
ex) Human gildong;, Human chulsu; = 클래스형의 변수 선언

2. 인스턴스
클래스 = 설계도, 틀
클래스 '실체' 생성하려면 'new 클래스명()' 형식을 사용
new 연산자로 생성되는 클래스형의 '실체'를 인스턴스라고 하며,
인스턴스를 생성하는 것을 인스턴스화 라고 한다
ex) gildong = new Human();, chulsu = new Human(); = 클래스형 변수와 인스턴스의 연결 (참조값 대입)
=> 이것으로 fildong과 chulsu가 생성된 인스턴스를 참조
인스턴스의 참조
프로그램 실행 시에 동적으로 생성하는 실체를 객체(Object)라고 한다

x.y = x가 참조하는 인스턴스의 멤버(요소) y에 접근한다
. = ~의 로 해석
ex) gildong.name = 길동의 이름
같은 필드를 참조하더라도 인스턴스마다 새로운 주소를 할당 받기에 서로 값이 다르다
 
3. 기본값을 사용한 필드 초기화
별도의 값을 지정하지 않고 선언만 할 시, 자료형 각각이 가지는 기본적 값이 존재
문제점
초기화와 관련된 위험성
데이터 보호와 관련된 위험성

===개선하기===
1. 필드
필드의 키워드를 private로 사용하여 선언
다른 클래스에서 접근 불가능
데이터 은닉, 유지보수 용이

2. 생성자
메서드와 유사 But. 이름이 클래스와 동일 & 반환형 X
ex) Human chulsu = new Human("철수", 170, 60);
매개변수의 개수 및 자료형을 맞추지 않으면 컴파일 오류 발생
입력에 제약을 추가하여 오류를 줄인다
생성자의 역할 = 인스턴스를 최적으로 초기화하는 것
별도의 생성자를 정의하지 않아도 인스턴스가 생성된 이유 = 자바에서 기본 생성자를 자동적으로 추가

3. 메서드
ex)
String getName() { return name; }    getName = 이름을 불러오는 메서드
int getHeight() { return height; }    getHeight = 신장을 불러오는 메서드
int getWeight() { return weight; }    getWeight = 체중을 불러오는 메서드

void gainWeight(int w) { weight += w; }    인수 w에 지정한 값만큼 체중에 반영
void loseWeight(int w) { weight -= w; }    인수 w에 지정한 값만큼 체중에 반영

static 없이 선언된 메서드 = 인스턴스 메서드, 해당 클래스의 개별 인스턴스 단위로 만들어진다
이로인해 각각의 인스턴스는 자신만의 메서드를 같게 된다 = 반복 제거

static을 사용해 선언한 메서드 = 클래스 메서드

4. 메서드 호출과 메시지
객체 지향 프로그래밍 (OOP)의 관점에서 인스턴스 메서드를 호출하는 것 = 객체에 메시지를 보내는 것
생성자는 메서드가 아니다 = 메서드 처럼 호출이 불가능

메서드는 필드 값을 기반으로 처리
필요에 따라 필드 값을 변경

필드는 비공개 (외부로부터 보호) & 메서드와 필드를 연계 = 캡슐화

클래스 = 회로, 설계도, 틀
인스턴스 = 클래스를 기반으로 만들어진 객체
클래스형 변수 = 클래스를 기반으로 객체를 조작하기 위한 것
생성자 = 인스턴스를 실행함과 동시에, 이름, 신장, 체중을 각 필드에 세팅하는 것

this 참조
자기자신의 인스턴스를 참조한다
생성자 및 메서드는 자신을 실행한 인스턴스의 참조를 this에 가진다
자료형은 자신의 클래스형
필드와 같은 이름을 매개 변수에 부여 = 변수명 고민 X & 가시성 ↑
this.를 지정하지 않은 경우 = 필드가 아닌 매개변수를 가리키게 된다 (주의)